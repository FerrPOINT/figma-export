# Техническое задание: Система экспорта данных из Figma (Обновленная версия)

## 1. Общие требования

**Цель**: Локальное приложение для полного экспорта данных из Figma через плагин с максимальной детализацией для воссоздания идентичного дизайна.

**Архитектура**: 
- WebSocket сервер на Bun (порт 3055)
- Единственное подключение к плагину "Cursor MCP Plugin" как клиент
- Файловая система для хранения экспортированных данных
- Наше приложение выступает как экспортер данных из Figma через существующий плагин
- Последовательная обработка команд через одно WebSocket соединение

**Критерии качества**:
- Максимальная детализация всех элементов
- Немедленное сохранение на диск (не в память)
- Рекурсивная обработка всех вложенных элементов
- Четкая обработка ошибок с завершением процесса

## 2. Функциональные требования

### 2.1 Экспортируемые данные
- Структура документа (страницы, фреймы, компоненты)
- Стили (цвета, типографика, эффекты, сетки)
- Компоненты и их варианты
- Метаданные документа
- Аннотации и комментарии
- Текстовые элементы с форматированием
- Графические элементы (векторы, изображения, фигуры)
- Интерактивность (реакции, переходы, анимации)
- Переопределения компонентов
- Связи между нодами
- Изображения и экспортированные ресурсы

### 2.2 Алгоритм экспорта (ИСПРАВЛЕННАЯ ВЕРСИЯ)

#### Этап 1: Инициализация
1. Очистка папки `export` и создание структуры подпапок
2. Сброс состояния экспорта (processedNodes, nodeQueue, savedFiles)
3. Запуск WebSocket сервера на порту 3055
4. Ожидание ручного подключения пользователя через плагин в Figma
5. Автоматическое определение единственного соединения с плагином
6. Установка таймаута на 300 секунд (5 минут) для ожидания ответов от больших файлов

#### Этап 2: Получение базовой структуры
1. Отправка команды `read_my_design` в Figma плагин
2. Ожидание ответа с полной структурой документа
3. Немедленное сохранение структуры в `export/structure/document_structure.json`
4. **ИСПРАВЛЕНИЕ**: Корректное извлечение всех node ID из структуры документа
5. Валидация полученных данных (наличие children, корректность структуры)

#### Этап 3: Параллельный экспорт метаданных
1. Отправка команды `get_styles` → сохранение в `export/styles/`
2. Отправка команды `get_local_components` → сохранение в `export/components/`
3. Отправка команды `get_document_info` → сохранение в `export/metadata/`
4. Отправка команды `get_annotations` → сохранение в `export/annotations/` (с обработкой ошибок)

#### Этап 4: Рекурсивная обработка нод (ИСПРАВЛЕННЫЙ)
1. **Извлечение ID**: Чтение сохраненной структуры документа и извлечение всех уникальных node ID
2. **Фильтрация**: Исключение уже обработанных ID из Set processedNodes
3. **Батчевая группировка**: Разделение ID на батчи по 5 нод (для отладки)
4. **Последовательная обработка**: Отправка команд `get_nodes_info` для каждого батча
5. **Немедленное сохранение**: Каждый полученный ответ сохраняется в соответствующий файл
6. **Обновление состояния**: Добавление обработанных ID в processedNodes

#### Этап 5: Специализированный экспорт (АКТУАЛИЗИРОВАННЫЙ)
1. **Текстовые элементы**: `scan_text_nodes` с параметрами (nodeId: "document", useChunking: true, chunkSize: 200, commandId: "text-scan")
2. **Элементы по типам**: `scan_nodes_by_types` для всех типов (nodeId: "document", types: ["FRAME", "COMPONENT", "TEXT", "VECTOR", "IMAGE", "RECTANGLE", "ELLIPSE", "POLYGON", "STAR", "LINE", "GROUP", "BOOLEAN_OPERATION", "REGULAR_POLYGON", "SLICE", "STAMP", "STICKY", "SHAPE_WITH_TEXT", "CONNECTOR", "CODE_BLOCK", "EMBED", "LINK_UNFURL", "MEDIA", "TABLE", "TABLE_CELL", "WASHI_TAPE", "WIDGET", "WIDGET_INSTANCE"])
3. **Связи между нодами**: `create_connections` для получения связей (connections: Array)
4. **Реакции и интерактивность**: `get_reactions` для получения реакций (nodeIds: string[])
5. **Переопределения компонентов**: `get_instance_overrides` для получения переопределений
6. **Текущее выделение**: `get_selection` для получения выделенных элементов
7. **Экспорт изображений нод**: `export_node_as_image` для экспорта изображений (КРИТИЧНО для 1:1)
8. **Полный экспорт всех нод**: УБРАНО - батчи уже содержат исчерпывающую информацию

#### Этап 6: Рекурсивное углубление
1. **Чтение сохраненных батчей**: Анализ файлов в `export/batches/`
2. **Извлечение новых ID**: Поиск вложенных node ID в сохраненных данных
3. **Повтор этапа 4**: Обработка новых найденных ID
4. **Проверка завершения**: Если новых ID нет → переход к финальному этапу

#### Этап 7: Финальная обработка
1. **Сбор статистики**: Подсчет обработанных нод, типов данных, команд
2. **Создание export_statistics.json** с метаданными экспорта
3. **Валидация полноты**: Проверка наличия всех типов данных
4. **Завершение процесса**: Успешное завершение или ошибка с описанием

#### Этап 8: Валидация результата
1. **Сканирование папки export**: Анализ всех созданных файлов и папок
2. **Проверка структуры**: Валидация соответствия требуемой структуре файлов
3. **Анализ содержимого**: Проверка размера файлов, корректности JSON
4. **Подсчет элементов**: Статистика по типам данных (стили, компоненты, ноды)
5. **Генерация отчета**: Создание validation_report.json с результатами проверки
6. **Вывод в консоль**: Подробный отчет о качестве экспорта

#### Ключевые принципы алгоритма:
- **Немедленное сохранение**: Каждый полученный блок данных сразу записывается на диск
- **Рекурсивность**: Обработка продолжается до исчерпания всех вложенных элементов
- **Батчевость**: Группировка запросов для оптимизации производительности
- **Последовательность**: Отправка команд через единственное соединение
- **Отказоустойчивость**: Таймауты и обработка ошибок на каждом этапе
- **Состояние**: Отслеживание прогресса через processedNodes и nodeQueue

### 2.2.1 ИСПРАВЛЕНИЯ В АЛГОРИТМАХ

#### Исправленная функция извлечения node ID:
```typescript
function extractNodeIdsFromStructure(structure: any): string[] {
  const nodeIds: string[] = [];
  
  function traverse(node: any) {
    if (node && node.id) {
      nodeIds.push(node.id);
    }
    if (node && node.children && Array.isArray(node.children)) {
      node.children.forEach(traverse);
    }
  }
  
  // Обрабатываем структуру документа
  if (structure && typeof structure === 'object') {
    // Если это массив, обрабатываем каждый элемент
    if (Array.isArray(structure)) {
      structure.forEach(traverse);
    } else {
      // Если это объект с числовыми ключами (результат read_my_design)
      if (Object.keys(structure).every(key => !isNaN(Number(key)))) {
        console.log(`🔍 Detected object with numeric keys (read_my_design result)`);
        // Обрабатываем каждый элемент объекта
        Object.values(structure).forEach((item: any) => {
          if (item && item.document) {
            traverse(item.document);
          } else if (item && item.id) {
            traverse(item);
          }
        });
      } else {
        // Если это обычный объект, обрабатываем его
        traverse(structure);
      }
    }
  }
  
  return nodeIds;
}
```

#### Исправленная обработка ошибок аннотаций:
```typescript
} else if (messageId.includes('annotations')) {
  // Проверяем, есть ли ошибка в ответе
  if (data.message && data.message.error) {
    console.log(`⚠️ Annotations command returned error: ${data.message.error}`);
    // Сохраняем информацию об ошибке, но продолжаем экспорт
    saveDataImmediately('annotations', { error: data.message.error, result: {} });
  } else {
    saveDataImmediately('annotations', result);
    console.log(`💾 Saved annotations data`);
  }
  exportState.stage3Completed++;
}
```

### 2.3 Структура файлов
```
export/
├── metadata/
│   ├── document_info.json
│   └── export_statistics.json
├── structure/
│   └── document_structure.json
├── styles/
│   ├── colors.json
│   ├── typography.json
│   ├── effects.json
│   └── grids.json
├── components/
│   └── local_components.json
├── nodes/
│   ├── text_nodes.json
│   ├── vector_nodes.json
│   └── nodes_by_types.json
├── interactions/
│   ├── reactions.json
│   └── connections.json
├── overrides/
│   └── instance_overrides.json
├── annotations/
│   └── all_annotations.json
├── images/
│   ├── node_images.json
│   └── all_nodes_export.json
├── batches/
│   └── batch_*.json
└── logs/
    └── *.json
```

## 3. Технические требования

### 3.1 WebSocket сервер
- **Платформа**: Bun runtime
- **Порт**: 3055
- **Протокол**: WebSocket для подключения к плагину "Cursor MCP Plugin"
- **Роль**: Клиент для экспорта данных из Figma через существующий плагин
- **Процесс подключения**: 
  - Запуск сервера и ожидание ручного подключения
  - Пользователь нажимает кнопку в плагине Figma
  - Автоматическое определение единственного соединения
  - Установка единственного соединения для экспорта данных
- **Управление соединением**: Единственное WebSocket соединение с проверкой состояния

### 3.2 Плагин "Cursor MCP Plugin"

#### 3.2.1 Установка плагина
1. Откройте Figma
2. Перейдите в Plugins → Development → Import plugin from manifest
3. Выберите файл `src/cursor_mcp_plugin/manifest.json`
4. Плагин появится в списке как "Cursor MCP Plugin"

#### 3.2.2 Конфигурация плагина
```json
{
  "name": "Cursor MCP Plugin",
  "id": "cursor-mcp-plugin",
  "api": "1.0.0",
  "main": "code.js",
  "ui": "ui.html",
  "editorType": ["figma", "figjam"],
  "permissions": [],
  "networkAccess": {
    "allowedDomains": ["https://google.com"],
    "devAllowedDomains": [
      "http://localhost:3055",
      "ws://localhost:3055"
    ]
  },
  "documentAccess": "dynamic-page",
  "enableProposedApi": true,
  "enablePrivatePluginApi": true
}
```

#### 3.2.3 Интерфейс плагина
- **Порт**: Настраиваемый порт (по умолчанию 3055)
- **Кнопка Connect**: Подключение к WebSocket серверу
- **Статус соединения**: Отображение состояния подключения
- **Прогресс операций**: Отображение прогресса экспорта

#### 3.2.4 Процесс подключения
1. Плагин генерирует случайное имя канала
2. Отправляет сообщение `join` с именем канала
3. Сервер подтверждает подключение сообщением `system`
4. Устанавливается WebSocket соединение для обмена данными

### 3.3 Команды плагина Cursor MCP Plugin

#### 3.3.1 Основные команды экспорта
```javascript
// Получение структуры документа
read_my_design              // Возвращает объект с числовыми ключами и деталями нод

// Метаданные документа
get_document_info           // Метаданные документа (имя, ID, тип, children)
get_styles                  // Все стили (цвета, типографика, эффекты)
get_local_components        // Локальные компоненты и их варианты
get_annotations             // Аннотации и комментарии (с обработкой ошибок)

// Детальная информация о нодах
get_node_info               // Информация об отдельной ноде (nodeId: string)
get_nodes_info              // Детальная информация о группе нод (nodeIds: string[])
get_reactions               // Реакции и интерактивность (nodeIds: string[])
get_instance_overrides      // Переопределения компонентов

// Специализированные команды
scan_text_nodes             // Сканирование всех текстовых элементов
scan_nodes_by_types         // Сканирование нод по типам
create_connections          // Связи между нодами (только FigJam)

// Экспорт изображений (КРИТИЧНО для 1:1 воссоздания)
export_node_as_image        // Экспорт изображения конкретной ноды
get_selection               // Получение текущего выделения
```

#### 3.3.2 Структура ответов плагина

**read_my_design** возвращает:
```javascript
{
  "0": {
    "nodeId": "3144:56343",
    "document": {
      "id": "3144:56343",
      "name": "Вакансии v2",
      "type": "FRAME",
      "children": [...]
    }
  },
  "1": {
    "nodeId": "3144:56511", 
    "document": {
      "id": "3144:56511",
      "name": "Ответы кандидата",
      "type": "FRAME",
      "children": [...]
    }
  }
  // ... и т.д.
}
```

**Примечание**: Команда `export_all_nodes` была удалена, так как батчи уже содержат исчерпывающую информацию о всех нодах.

#### 3.3.3 Важные замечания по командам

**Примечание о батчах**: Батчи (`export/batches/`) содержат исчерпывающую информацию о всех нодах:
- ✅ **973 ноды** с полной структурой
- ✅ **Детальная информация**: `absoluteBoundingBox`, `fills`, `strokes`, `characters`, `style`
- ✅ **Иерархия**: `parentId` связи сохранены
- ✅ **Все типы нод**: фреймы, текст, компоненты, экземпляры
- ✅ **19 батчей** по 5 нод каждый

Поэтому команда `export_all_nodes` была удалена как избыточная.

**Параметры nodeId:**
- `'current'` - НЕ работает (ошибка "Node not found")
- `'root'` - НЕ работает (ошибка "Node not found") 
- `'document'` - Рекомендуется для сканирования всего документа
- Реальные ID нод - Для работы с конкретными нодами

**Ограничения команд:**
- `create_connections` - Работает только в FigJam, не в Figma
- `set_default_connector` - Работает только в FigJam
- `get_reactions` - Требует массив nodeIds, не может быть пустым
- `get_instance_overrides` - Возвращает ошибку если нет экземпляров компонентов
- `get_annotations` - Может возвращать ошибку "cannot convert to object"

**Рекомендуемые параметры:**
```javascript
// scan_text_nodes
{
  nodeId: 'document',        // ID документа
  useChunking: true,         // Включить чанкинг
  chunkSize: 200,           // Размер чанка
  commandId: 'unique-id'     // Уникальный ID команды
}

// scan_nodes_by_types
{
  nodeId: 'document',        // ID документа
  types: ['FRAME', 'TEXT', 'COMPONENT', ...] // Массив типов
}

// get_reactions
{
  nodeIds: ['document']      // Массив ID нод (не пустой!)
}

// get_instance_overrides
{
  // Без параметров или с instanceNodeId
}

// export_all_nodes - УБРАНО (батчи уже содержат исчерпывающую информацию)
```

### 3.3 Обработка ошибок
- **Fail-fast принцип**: Любая ошибка → немедленное завершение процесса
- **Валидация**: Проверка структуры ответов и корректности данных
- **Завершение**: `process.exit(1)` при любой критической ошибке
- **Логирование**: Подробные логи с контекстом ошибки и stack trace
- **Недопустимо**: Продолжение работы после ошибки
- **Таймауты**: 300 секунд (5 минут) для больших файлов
- **Обработка ошибок аннотаций**: Сохранение информации об ошибке, но продолжение экспорта

### 3.4 Производительность
- **Батчевая обработка**: 5 нод за раз (для отладки)
- **Последовательная отправка**: Команды через единственное соединение
- **Задержка между командами**: 1 секунда для стабильности
- **Немедленное сохранение**: Каждый блок данных
- **Рекурсивный обход**: По сохраненным файлам
- **Оптимизация памяти**: Не держать большие объемы в RAM

### 3.5 Валидация результата
- **Автоматическое сканирование**: Анализ всей папки export после завершения
- **Проверка структуры**: Валидация соответствия требуемой иерархии файлов
- **Анализ содержимого**: Проверка корректности JSON, размера файлов
- **Подсчет элементов**: Статистика по типам данных (стили, компоненты, ноды)
- **Генерация отчета**: Создание validation_report.json с детальными результатами
- **Консольный вывод**: Подробный отчет о качестве экспорта в терминале

## 4. Логирование

### 4.1 Безопасное логирование больших данных

#### 4.1.1 ПРАВИЛА ЛОГИРОВАНИЯ (ОБЯЗАТЕЛЬНЫЕ)
- **ВСЕ большие данные сначала сохраняются на диск**
- **В лог выводится только первые 100 символов**
- **Обязательно добавлять комментарии о том, что данные большие**
- **Использовать утилиту `safeLog` для всех текстовых файлов**

#### 4.1.2 Утилита безопасного логирования
```typescript
// src/utils/logger.ts
import { safeLog, logIncomingMessage, logOutgoingCommand } from "./utils/logger";

// Для больших данных (файлы именуются по ID):
safeLog({
  message: "Saved large data",
  data: largeData,
  dataType: "data_type",
  filePath: "path/to/file.json",
  maxPreviewLength: 100
});

// Для входящих сообщений:
logIncomingMessage("Received message", data);

// Для исходящих команд:
logOutgoingCommand("Sending command", commandData);
```

#### 4.1.3 Именование файлов по ID
**ПРАВИЛА ИМЕНОВАНИЯ ФАЙЛОВ:**
- **batch** - `batch_{messageId}.json` (ID сообщения)
- **images** - `image_{nodeId}.json` (ID ноды)
- **all_nodes_export** - `all_nodes_export_{commandId}.json` (ID команды)
- **logs** - `{dataType}_{id}.json` (ID из данных)
- **Очистка ID** - удаление недопустимых символов `[<>:"/\\|?*]`

#### 4.1.3 Уровни логов
- `📥` - Входящие сообщения (с превью)
- `📤` - Исходящие команды (с превью)
- `🔍` - Отладочная информация
- `📊` - Анализ данных
- `💾` - Сохранение файлов (с превью)
- `❌` - Ошибки
- `✅` - Успешные операции
- `🔗` - Управление соединением

### 4.2 Информативность
- Структура получаемых данных (превью)
- Количество элементов каждого типа
- Прогресс обработки
- Метаданные экспорта
- Состояние единственного соединения
- Последовательность отправки команд
- Отладочная информация о структуре данных
- Размер файлов и пути сохранения

## 5. Критерии приемки

### 5.1 Функциональные
- [x] Экспорт всех типов данных
- [x] Рекурсивная обработка вложенных элементов
- [x] Немедленное сохранение на диск
- [x] Структурированная организация файлов
- [x] Обработка ошибок с завершением процесса
- [x] Корректное извлечение всех node ID из структуры документа
- [x] Полное выполнение всех этапов экспорта (Stage 4, 5, 6)

### 5.2 Производительность
- [x] Экспорт без зависаний
- [x] Оптимизированное использование памяти
- [x] Быстрая обработка больших документов
- [x] Батчевая обработка для скорости
- [x] Стабильная работа через единственное соединение
- [x] Последовательная отправка команд с задержками

### 5.3 Качество
- [x] Максимальная детализация всех элементов
- [x] Возможность воссоздания идентичного дизайна
- [x] Подробные логи для диагностики
- [x] Стабильная работа без таймаутов
- [x] Надежное управление единственным соединением
- [x] Корректная обработка разрыва соединения

### 5.4 Валидация
- [x] Автоматическая проверка структуры файлов
- [x] Валидация корректности JSON во всех файлах
- [x] Подсчет и анализ всех типов данных
- [x] Генерация подробного отчета о качестве экспорта
- [x] Вывод результатов валидации в консоль

## 6. Ограничения

- **Платформа**: Только локальное использование
- **Безопасность**: Не требуется
- **UI**: Не требуется
- **Формат**: JSON для максимальной детализации
- **Размер**: Без ограничений по времени и размеру файлов

## 7. Что НЕ нужно делать

### 7.1 Не реализовывать собственный плагин
- Используем существующий плагин "Cursor MCP Plugin"
- Не создаем новый плагин для Figma
- Не дублируем функциональность существующего решения

### 7.2 Не использовать MCP протокол
- Наше приложение НЕ является MCP сервером
- Работаем через WebSocket с плагином
- Не реализуем Model Context Protocol

### 7.3 Не создавать UI/UX
- Нет необходимости в пользовательском интерфейсе
- Работаем через командную строку
- Не разрабатываем веб-интерфейс или GUI

### 7.4 Не добавлять избыточную функциональность
- Не реализуем редактирование данных
- Не создаем систему версионирования
- Не добавляем функции синхронизации
- Не реализуем облачное хранение

### 7.5 Не усложнять архитектуру
- Не добавляем базу данных
- Не создаем микросервисы
- Не реализуем кэширование
- Не добавляем аутентификацию

### 7.6 Не оптимизировать преждевременно
- Не добавляем сложные алгоритмы без необходимости
- Не реализуем предварительную оптимизацию
- Фокус на функциональности, а не на производительности 

## 8. Текущие проблемы и их решения

### 8.1 ✅ РЕШЕНО: Проблема с извлечением node ID
**Проблема**: Функция `extractNodeIdsFromStructure` не извлекала ID из структуры документа
**Причина**: `read_my_design` возвращает объект с числовыми ключами, а не массив
**Решение**: ✅ Добавлена обработка объектов с числовыми ключами и отладочная информация

### 8.2 ✅ РЕШЕНО: Проблема с аннотациями
**Проблема**: Команда `get_annotations` возвращала ошибку "cannot convert to object"
**Решение**: ✅ Добавлена обработка ошибок с сохранением информации об ошибке

### 8.3 ✅ РЕШЕНО: Пропущенные этапы
**Проблема**: Stage 4, 5, 6 не выполнялись из-за отсутствия node ID
**Причина**: Неправильная обработка структуры данных от `read_my_design`
**Решение**: ✅ Исправлена функция извлечения ID и добавлена корректная обработка всех этапов

### 8.4 ✅ РЕШЕНО: Неполный экспорт
**Проблема**: Экспорт завершался на Stage 3, не выполняя рекурсивную обработку
**Причина**: Неправильная обработка структуры данных от плагина
**Решение**: ✅ Исправлена логика извлечения ID и добавлена корректная обработка всех этапов

### 8.5 ✅ РЕШЕНО: Команда export_all_nodes
**Проблема**: Команда `export_all_nodes` возвращала "Unknown command"
**Причина**: Несоответствие между camelCase и snake_case в именах команд
**Решение**: ✅ Исправлено имя команды в сервере с `exportAllNodesWithStackAlgorithm` на `export_all_nodes`

### 8.6 ✅ РЕШЕНО: Безопасное логирование
**Проблема**: В логах отображались слишком большие сообщения
**Решение**: ✅ Создана утилита `safeLog` для безопасного логирования больших данных

### 8.7 ✅ РЕШЕНО: Именование файлов
**Проблема**: Файлы перезаписывались из-за одинаковых имен
**Решение**: ✅ Реализовано именование файлов по ID с очисткой недопустимых символов

### 8.8 ✅ РЕШЕНО: Последовательная обработка Stage 4
**Проблема**: `get_nodes_info` зависал из-за параллельной обработки
**Решение**: ✅ Реализована последовательная батчевая обработка для Stage 4

### 8.9 Структура данных плагина
**Особенность**: `read_my_design` возвращает объект с числовыми ключами
**Пример**:
```javascript
{
  "0": {
    "nodeId": "3144:56343",
    "document": {
      "id": "3144:56343",
      "name": "Вакансии v2",
      "type": "FRAME",
      "children": [...]
    }
  },
  "1": {
    "nodeId": "3144:56511", 
    "document": {
      "id": "3144:56511", 
      "name": "Ответы кандидата",
      "type": "FRAME",
      "children": [...]
    }
  }
}
```

**Решение**: ✅ Обработка каждого элемента объекта и извлечение ID из `document` свойств

### 8.10 Текущий статус проекта
**✅ ВСЕ ОСНОВНЫЕ ПРОБЛЕМЫ РЕШЕНЫ:**
- ✅ Корректное извлечение node ID
- ✅ Полное выполнение всех этапов экспорта
- ✅ Безопасное логирование больших данных
- ✅ Правильное именование файлов по ID
- ✅ Последовательная обработка команд
- ✅ Команда `export_all_nodes` работает корректно
- ✅ Все этапы экспорта выполняются полностью
- ✅ **ИСПРАВЛЕНО: Рекурсивная обработка всех вложенных нод в батчах**

### 8.11 ✅ РЕШЕНО: Проблема с неполной обработкой батчей
**Проблема**: Функция `processBatchesAndOrganizeData()` обрабатывала только верхний уровень нод, игнорируя вложенные элементы
**Причина**: Отсутствие рекурсивного обхода структуры `children` в батчах
**Решение**: ✅ Добавлена функция `traverseNode()` для рекурсивного обхода всех вложенных элементов
**Результат**: 
- Извлечение всех 513+ нод вместо 168
- Сохранение полной иерархии с `parentId`
- Добавление дополнительных свойств (`absoluteBoundingBox`, `fills`, `strokes`, `characters`, `style`, `cornerRadius`)

**🎯 ПРОЕКТ ГОТОВ К ИСПОЛЬЗОВАНИЮ!** 